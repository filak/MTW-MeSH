### Search/Text query v2.0
## All Descriptors & Concepts
## params: query string [+ filter: active=false]

{% include 'sparql/_namespaces.sparql' %}

{% if config.USE_PROP_LISTS %}
    {% if qtp == 'all' %}
        {% set prop_list = 'mesht:queryAll' %}
    {% elif qtp == 'notes' %}
        {% set prop_list = 'mesht:queryNotes' %}
    {% elif qtp == 'def' %}
        {% set prop_list = 'mesht:queryDef' %}
    {% else %}
        {% set prop_list = 'mesht:queryDef' %}
    {% endif %}
{% else %}
    {% set prop_list = '' %}
{% endif %}

SELECT
   (MAX(?score) AS ?topscore)
   (?label_en AS ?label)
   (?descriptor AS ?d)
   (?dtype AS ?type)
    ?active
    (GROUP_CONCAT(DISTINCT ?label_cs; separator=" | ") AS ?val)
    ?scn
    ?scnt
    ?ntx
    ?lockedBy
WHERE {

SELECT DISTINCT
    ?score
    ?descriptor
    ?dtype
    ?label_en
    ?label_cs
    ?active
    ?scn
    ?scnt
    ?ntx
    ?lockedBy
WHERE {

  #################################################################
  # 1. TEXT SEARCH - ?s is the term node
  #################################################################

  {% if slang == 'target' %}
      # Target lang
      (?s ?score) text:query ({{ prop_list }} "{{ query }}" 500 "lang:{{ lang }}") .
  {% elif slang == 'source' %}
      # Source lang: en
      (?s ?score) text:query ({{ prop_list }} "{{ query }}" 500 "lang:en") .
  {% else %}
      (?s ?score) text:query ({{ prop_list }} "{{ query }}" 500) .
  {% endif %}

  #################################################################
  # 2. RESOLVE CONCEPT AND DESCRIPTOR (meshv path)
  #################################################################

  OPTIONAL {
    ?c meshv:preferredTerm|meshv:term ?s .
    ?d1 meshv:preferredConcept|meshv:concept ?c .
    ?d1 rdf:type ?dtype1 .
    FILTER(?dtype1 IN (
      meshv:TopicalDescriptor,
      meshv:GeographicalDescriptor,
      meshv:PublicationType,
      meshv:CheckTag,
      meshv:Qualifier
    ))
  }

  OPTIONAL {
    ?d2 meshv:preferredConcept ?s .
    ?d2 rdf:type ?dtype2 .
    FILTER(?dtype2 IN (
      meshv:TopicalDescriptor,
      meshv:GeographicalDescriptor,
      meshv:PublicationType,
      meshv:CheckTag,
      meshv:Qualifier
    ))
  }

  {% if scr == 'yes' %}
    OPTIONAL {
	    ?s meshv:mappedTo|meshv:preferredMappedTo|meshv:pharmacologicalAction ?dm .
	    ?dm rdf:type ?mtype .
	    FILTER (?mtype IN(meshv:TopicalDescriptor,meshv:Descriptor))
    }
  {% endif %}

  #################################################################
  # 3. RESOLVE CONCEPT AND DESCRIPTOR (mesht path)
  #################################################################

  OPTIONAL {
    ?c3 mesht:preferredTerm|mesht:term ?s .
    ?d3 meshv:preferredConcept|meshv:concept|mesht:concept ?c3 .
    ?d3 rdf:type ?dtype3 .
    FILTER(?dtype3 IN (
      meshv:TopicalDescriptor,
      meshv:GeographicalDescriptor,
      meshv:PublicationType,
      meshv:CheckTag,
      meshv:Qualifier
    ))
  }

  #################################################################
  # 4. MERGE DESCRIPTOR & TYPE
  #################################################################

  BIND(COALESCE(?d1, ?d2, ?d3, ?dm) AS ?descriptor)
  BIND(COALESCE(?dtype1, ?dtype2, ?dtype3, ?mtype) AS ?dtype)
  FILTER(BOUND(?descriptor))

  #################################################################
  # 5. PREFERRED TERM LABELS
  #################################################################

  OPTIONAL {
    ?descriptor meshv:preferredConcept ?concept .
    ?concept meshv:preferredTerm ?pt .
    ?pt meshv:prefLabel ?label_en .
    FILTER(lang(?label_en) = "en")
  }

  # Czech (optional)
  OPTIONAL {
    ?descriptor meshv:preferredConcept ?concept2 .
    ?concept2 mesht:preferredTerm ?pt2 .
    ?pt2 mesht:prefLabel ?label_cs .
    FILTER(lang(?label_cs) = "cs")
  }

  #################################################################
  # 6. METADATA
  #################################################################
  # active (absence = true)
  BIND(IF(EXISTS { ?descriptor meshv:active false }, false, true) AS ?active)

  OPTIONAL {?descriptor mesht:lockedBy ?lockedBy }

  # Scope notes
  OPTIONAL {
    ?concept meshv:scopeNote ?_scn .
    BIND("YES" AS ?scn)
  }

  OPTIONAL {
    ?concept2 mesht:scopeNote ?_scnt .
    BIND("YES" AS ?scnt)
  }

  #################################################################
  # 7. FILTERS
  #################################################################

  FILTER(BOUND(?label_en) || BOUND(?label_cs))

  {% if status == 'active' %}
      # Only active
      FILTER (?active)
  {% elif status == 'deleted' %}
      # Only deleted
      FILTER (!?active)
  {% elif status == 'revised' %}
      # Only revised
      ?descriptor meshv:dateRevised|lastUpdated ?dateRev .
      FILTER(?dateRev >= "{{ config.REVISED_AFTER }}"^^xsd:date)
  {% elif status == 'new' %}
      # Only new
      ?descriptor meshv:dateCreated ?dateCrt .
      FILTER(?dateCrt >= "{{ config.CREATED_AFTER }}"^^xsd:date)
  {% endif %}

  {% if show == 'ntx' %}
    # Not translatable flags
    OPTIONAL { ?c mesht:notTranslatable ?ntx }
  {% endif %}

  {% if show == 'translated' %}
      FILTER(BOUND(?label_cs))
  {% elif show == 'todo' %}
      FILTER(!BOUND(?label_cs))
  {% elif show == 'scn' %}
      FILTER(BOUND(?label_cs))   ## translated
      FILTER(BOUND(?scn))   ## scopeNote present
      FILTER(!BOUND(?scnt)) ## not translatedScopeNote
  {% elif show == 'ntx' %}
      FILTER(BOUND(?ntx))
  {% endif %}

}
ORDER BY DESC(?score)
LIMIT 500
}
GROUP BY
    ?descriptor
    ?dtype
    ?label_en
    ?active
    ?scn
    ?scnt
    ?ntx
    ?lockedBy
ORDER BY DESC(?topscore) ?label_en
